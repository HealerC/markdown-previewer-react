{"version":3,"sources":["instance-state-styles.js","editor.js","previewer.js","app.js","index.js"],"names":["WindowSizes","flexBasis","order","flexGrow","onFocus","titleBar","backgroundColor","textAreaShadow","boxShadow","onBlur","Editor","props","state","isFocused","focusView","bind","blurView","toggleMaximize","this","identity","maximized","handleMaximize","setState","presentStyle","id","style","icon","onClick","handleClear","size","className","title","handleAddPreviewer","onChange","handleChange","value","text","React","Component","marked","setOptions","gfm","breaks","Previewer","isHTMLView","getMarkedText","toggleView","closeComponent","handleClose","dangerouslySetInnerHTML","__html","library","add","fab","fas","faWindowRestore","faWindowMaximize","onMaximizeMain","onMaximizeOthers","App","editorText","previewerCount","previewerIDs","maximizedComponent","addPreviewer","closePreviewer","createPreviewer","event","target","length","nextDigit","concat","index","indexOf","splice","key","previewerList","editorStyle","i","push","href","rel","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.52aed464.chunk.js","sourcesContent":["/*\r\n *  Just the style in Javascript Object Form of the Components when they are maximized\r\n *  or restored AND\r\n *  The Editor when it has or has lost the focus.\r\n */\r\nconst WindowSizes = {\r\n    onMaximizeMain: {           // The maximized component\r\n        flexBasis: \"100%\",\r\n        order: 1\r\n    },\r\n    onMaximizeOthers: {         // The other components when there is a maximized component\r\n        flexBasis: \"40%\",\r\n        flexGrow: 0,\r\n        order: 2\r\n    }\r\n}\r\n\r\nconst EditorStates = {\r\n    onFocus: {                  // When the editor has focus\r\n        titleBar: {\r\n            backgroundColor: \"rgb(245, 134, 52)\"\r\n        },\r\n        textAreaShadow: {\r\n            boxShadow: \"0 4px 8px 0 rgba(245, 134, 52, 0.5), 0 6px 20px 0 rgba(245, 134, 52, 0.19)\"\r\n        },\r\n    },\r\n    onBlur: {                   // When the editor has lost focus\r\n        titleBar: {\r\n            backgroundColor: \"gray\"\r\n        },\r\n        textAreaShadow: {\r\n            boxShadow: \"0 4px 8px 0 rgba(0, 0, 0, 0.2), 0 6px 20px 0 rgba(0, 0, 0, 0.19)\"\r\n        }\r\n    }\r\n}\r\nexport { WindowSizes, EditorStates };","import React from 'react';\r\nimport { FontAwesomeIcon } from '@fortawesome/react-fontawesome';\r\nimport { EditorStates } from './instance-state-styles.js';\r\nconst { onFocus, onBlur } = EditorStates;\r\n\r\nclass Editor extends React.Component {\r\n    /*\r\n     *  This editor displays what it is given from it's parent app\r\n     *  It basically handles changes in its textarea value and passes is it to its\r\n     *  parent (App) which then (The App) passes it back to it to render it.\r\n     *  It renders different colours when it has/lost the input focus \r\n     */\r\n    constructor(props){\r\n        super(props);\r\n        this.state = {\r\n            isFocused: false         // Does the component have the input focus?\r\n        }\r\n        this.focusView = this.focusView.bind(this);\r\n        this.blurView = this.blurView.bind(this);\r\n        this.toggleMaximize = this.toggleMaximize.bind(this);\r\n    }\r\n    toggleMaximize() {\r\n        /* If it is not maximized it tells the \"App\" it wants to be maximized\r\n           by passing its \"identity\" but if it wants to be restored,\r\n           it also tells the app by passing -1. It knows which component\r\n           is maximized because the maximized component was passed as one of the props */\r\n        if (this.props.identity === this.props.maximized) {\r\n            this.props.handleMaximize(-1);    \r\n        } else {\r\n            this.props.handleMaximize(this.props.identity);\r\n        }\r\n    }\r\n    focusView() {\r\n        /* Does it have focus? */\r\n        this.setState({\r\n            isFocused: true\r\n        });\r\n    }\r\n    blurView() {\r\n        /* Has it lost focus? */\r\n        this.setState({\r\n            isFocused: false\r\n        });\r\n    }\r\n    render() {\r\n        let presentStyle = {};          // The style to render will depend on its focus\r\n        if (this.state.isFocused) {\r\n            presentStyle = onFocus;\r\n        } else {\r\n            presentStyle = onBlur;\r\n        }\r\n        return (\r\n            <div id=\"editorPane\" style={this.props.style}>\r\n                <div id=\"titleBar\" style={presentStyle.titleBar}>\r\n                    <h2>Editor</h2>\r\n                    <span id=\"actionButtons\">\r\n                      <FontAwesomeIcon icon={[\"fas\", \"trash\"]} onClick={this.props.handleClear} size=\"lg\"  \r\n                        className=\"icon\" title=\"Clear Editor\" />\r\n                      \r\n                      {/* Renders maximize/restore icons based on whether it is the maximized component*/}\r\n                      { this.props.identity === this.props.maximized ? \r\n                         <FontAwesomeIcon icon=\"window-restore\" size=\"lg\"  \r\n                           className=\"icon\" onClick={this.toggleMaximize} title=\"Restore\" /> :\r\n                          <FontAwesomeIcon icon=\"window-maximize\" size=\"lg\"  \r\n                            className=\"icon\" onClick={this.toggleMaximize} title=\"Maximize\" /> }\r\n                        \r\n                        <FontAwesomeIcon icon={[\"fas\", \"plus\"]} onClick={this.props.handleAddPreviewer} \r\n                          size=\"lg\" className=\"icon\" title=\"Add previewer\" />\r\n                    </span>\r\n                </div>\r\n\r\n                {/* The markdown input */}\r\n                <textarea onChange={this.props.handleChange} onFocus={this.focusView} onBlur={this.blurView}\r\n                    value={this.props.text} id=\"editor\" style={presentStyle.textAreaShadow} />\r\n            </div>\r\n        );\r\n    }\r\n}\r\n\r\nexport default Editor;","import React from 'react';\r\nimport { FontAwesomeIcon } from '@fortawesome/react-fontawesome';\r\nimport marked from 'marked';          // Library that will be parsing the text\r\nimport './previewerCSS.css';          // The styles it will apply to the output\r\nmarked.setOptions({                 \r\n    // So that new line will be parsed as line break (optional bonus) \r\n    gfm: true,\r\n    breaks: true\r\n});\r\n\r\nclass Previewer extends React.Component {\r\n    /*\r\n     *  The previewer's role is simple. Get the user-typed markdown text from the\r\n     *  parent \"App\" and display it in HTML form. It can toggle between pure html\r\n     *  markup text or render it as it would in a browser (default).\r\n     *  \r\n     *  Pure HTML used here means text rendered using the HTML tags \r\n     */\r\n    constructor(props) {\r\n        super(props);\r\n        this.state = {\r\n            isHTMLView: false           // Default value. Render as normal\r\n        }\r\n        this.getMarkedText = this.getMarkedText.bind(this);\r\n        this.toggleView = this.toggleView.bind(this);\r\n        this.closeComponent = this.closeComponent.bind(this);\r\n        this.toggleMaximize = this.toggleMaximize.bind(this);\r\n    }\r\n    getMarkedText(text) {\r\n        return marked(text);\r\n    }\r\n    toggleView() {\r\n        /*\r\n         *  Toggle between showing the rendered HTML or the pure (with all its tags)\r\n         */\r\n        this.setState(state => ({\r\n            isHTMLView: !state.isHTMLView\r\n        }));\r\n    }\r\n    closeComponent() {\r\n        /*\r\n         *  Tells the parent \"App\" it wants to close by passing it its identity\r\n         */\r\n        this.props.handleClose(this.props.identity);\r\n    }\r\n    toggleMaximize() {\r\n        /* If it is not maximized it tells the \"App\" it wants to be maximized\r\n           by passing its \"identity\" but if it wants to be restored,\r\n           it also tells the app by passing -1. It knows which component\r\n           is maximized because the maximized component was passed as one of the props */\r\n        if (this.props.identity === this.props.maximized) {\r\n            this.props.handleMaximize(-1);    \r\n        } else {\r\n            this.props.handleMaximize(this.props.identity);\r\n        }\r\n    }\r\n    render() {\r\n        return (\r\n            <div id=\"previewerPane\" style={this.props.style}>\r\n                <div id=\"titleBar\">\r\n                    <h2>Previewer #{this.props.identity}</h2>\r\n                    <span id=\"actionButtons\">\r\n                      {/* Render icon either HTML or pure HTML (HTML with tags) */}\r\n                      { this.state.isHTMLView ? \r\n                        <FontAwesomeIcon icon={[\"fab\", \"markdown\"]} onClick={this.toggleView} size=\"lg\" \r\n                          className=\"icon\" title=\"Markdown view\" /> :\r\n                        <FontAwesomeIcon icon={[\"fas\", \"code\"]} onClick={this.toggleView} size=\"lg\" \r\n                          className=\"icon\" title=\"HTML View\" /> }\r\n                    \r\n                      {/* Renders maximize/restore icons based on whether it is the maximized component*/}\r\n                      { this.props.identity === this.props.maximized ? \r\n                        <FontAwesomeIcon icon=\"window-restore\" size=\"lg\"  \r\n                          className=\"icon\" onClick={this.toggleMaximize} title=\"Restore\"/> :\r\n                        <FontAwesomeIcon icon=\"window-maximize\" size=\"lg\"  \r\n                          className=\"icon\" onClick={this.toggleMaximize} title=\"Maximize\" /> }\r\n                  \r\n                      {/* It is only previewers that can be closed. */}\r\n                      <FontAwesomeIcon icon={[\"fas\", \"times\"]} onClick={this.closeComponent} size=\"lg\"  \r\n                        className=\"icon\" title=\"Delete previewer\" />\r\n                    </span>\r\n                </div>\r\n                \r\n                {/* The HTML output */}\r\n                { this.state.isHTMLView ? \r\n                  <div id={this.props.id}>{this.getMarkedText(this.props.text)}</div> : \r\n                  <div id={this.props.id} dangerouslySetInnerHTML=\r\n                      {{__html: this.getMarkedText(this.props.text)}}></div> }\r\n            </div>\r\n        );\r\n    }\r\n}\r\n\r\nexport default Previewer;","import React from 'react';\r\nimport Editor from './editor.js';\r\nimport Previewer from './previewer.js';\r\nimport './app.scss';\r\n\r\n/* Fontawesome icons */\r\nimport { library } from '@fortawesome/fontawesome-svg-core';\r\nimport { fab } from '@fortawesome/free-brands-svg-icons';\r\nimport { fas } from '@fortawesome/free-solid-svg-icons';\r\nimport { faWindowRestore, faWindowMaximize } from '@fortawesome/free-regular-svg-icons';\r\n\r\n/* Maximizing and restoring */\r\nimport { WindowSizes } from './instance-state-styles.js';\r\n\r\nlibrary.add(fab, fas, faWindowRestore, faWindowMaximize);       // fontawesome\r\nlet { onMaximizeMain, onMaximizeOthers } = WindowSizes;         // maximizing and restoring\r\n\r\nclass App extends React.Component {\r\n    /*\r\n     *  The app handles most things in the markdown previewer app\r\n     *  from the markdown text to the number of previewers as well as the \r\n     *  layout of the app which changes as the number of previewers as well as their\r\n     *  maximized property changes.   \r\n     *  To do this it sends a lot of props to the children to tell them\r\n     *  what to show and how they should arrange\r\n     */\r\n    constructor(props) {\r\n        super(props);\r\n        this.state = {\r\n            editorText: \"\",         // Markdown text\r\n            previewerCount: 1,      // The total number of previewers rendered so far\r\n            previewerIDs: [1],      // The identities of the previewers rendered presently\r\n            maximizedComponent: 0   // The identity of the component rendered. \r\n        }\r\n        this.handleChange = this.handleChange.bind(this);\r\n        this.handleClear = this.handleClear.bind(this);\r\n        this.addPreviewer = this.addPreviewer.bind(this);\r\n        this.closePreviewer = this.closePreviewer.bind(this);\r\n        this.handleMaximize = this.handleMaximize.bind(this);\r\n        this.createPreviewer = this.createPreviewer.bind(this);\r\n    }\r\n    handleChange(event) {\r\n        /* When there's a change to the child editor component it should update its state */\r\n        this.setState({\r\n            editorText: event.target.value\r\n        });\r\n    }\r\n    handleClear() {\r\n        /* Remove all the text from the editor */\r\n        this.setState({\r\n            editorText: \"\"\r\n        });\r\n    }\r\n    addPreviewer() {\r\n        /* It should add to the previewers presently rendered by using the total\r\n        count of previewers as the identity for the next. Only two previewers are supported */\r\n        if (this.state.previewerIDs.length < 2) {\r\n            // Only two previewers can be added\r\n            this.setState(state => {\r\n                const nextDigit = state.previewerCount+1;\r\n                return {\r\n                    previewerIDs: state.previewerIDs.concat(nextDigit),\r\n                    previewerCount: nextDigit\r\n                }\r\n            });\r\n        }\r\n    }\r\n    closePreviewer(identity) {\r\n        /* The previewer that wants to be deleted will provide its identity and \r\n        the program just removes the identity from the identities saved in the state \r\n        as an array - previewerIDs */\r\n        this.setState(state => {\r\n            const index = state.previewerIDs.indexOf(identity);\r\n            state.previewerIDs.splice(index, 1);\r\n            return {\r\n                previewerIDs: state.previewerIDs\r\n            }\r\n        });\r\n    }\r\n    handleMaximize(identity) {\r\n        /* Only one component can be maximized at a time so when a new component\r\n        wants to be maximized the previously maximized component is overwritten\r\n        or if it wants to be minimized, it will pass -1 to the method and then\r\n        maximized component is set to 0. No component will be maximized then */\r\n        if (identity !== -1) {\r\n            this.setState({\r\n                maximizedComponent: identity\r\n            });\r\n        } else {\r\n            this.setState({\r\n                maximizedComponent: 0\r\n            });\r\n        }\r\n    }\r\n    createPreviewer(key, identity, style, maximized) {\r\n        /* This method creates and returns a previewer with a props\r\n        * which would be the arguments passed to the method */\r\n        return (<Previewer text={this.state.editorText} key={key} handleClose={this.closePreviewer} \r\n          handleMaximize={this.handleMaximize} identity={identity} id=\"preview\" \r\n          style={style} maximized={maximized} />);\r\n    }\r\n    render() {\r\n        let previewerList = [];     // The previewers to be rendered\r\n        let flexBasisValue = 0;     // The flex basis used when there is no maximized component\r\n        let editorStyle = {};       // The style the editor will use depending on the state\r\n        let key = 0;                // The key of each previewer (required in react)\r\n        let identity = 0;           // The identity of each previewer (used in program)\r\n        let style = {};             // The style that will be applied to each previewer\r\n        let maximized = this.state.maximizedComponent;          // The presently maximized component\r\n        for (let i = 0; i < this.state.previewerIDs.length; i++) {\r\n            // Data for the present previewer in the array\r\n            key = this.state.previewerIDs[i];       // required by react\r\n            identity = this.state.previewerIDs[i];\r\n\r\n            if (maximized) {\r\n                // A component was maximized - It can be either string 'editor' or the identity integer\r\n                // of the component if it is a previewer.\r\n                if (maximized === 'editor') {\r\n                    // An editor was maximized\r\n                    editorStyle = onMaximizeMain;\r\n                    \r\n                    // For this previewer\r\n                    style = onMaximizeOthers;\r\n                    previewerList.push(this.createPreviewer(key, identity, style, maximized));\r\n                  } else if (maximized > 0) {\r\n                    // One of the previewers is maximized so we need to find out which\r\n                    if (maximized === identity) {\r\n                        // This is the component presently being maximized\r\n                        style = onMaximizeMain;\r\n                        previewerList.push(this.createPreviewer(key, identity, style, maximized));    \r\n                    } else {\r\n                        // A previewer is being maximized but not this one\r\n                        style = onMaximizeOthers;\r\n                        previewerList.push(this.createPreviewer(key, identity, style, maximized));    \r\n                    }\r\n                    \r\n                    // The editor was not the one maximized\r\n                    editorStyle = onMaximizeOthers;\r\n                }\r\n            }\r\n            else {\r\n                // No maximized component - The style to use depends on the number of components\r\n                flexBasisValue = this.state.previewerIDs.length === 1 ? \"40%\" : \"30%\"\r\n                editorStyle = {flexBasis: flexBasisValue};\r\n                \r\n                style = editorStyle;        // This time the editor and all the previewers\r\n                                            // have the same style\r\n                previewerList.push(this.createPreviewer(key, identity, style, maximized));    \r\n            }\r\n                \r\n        }   \r\n        return (\r\n            <div>\r\n                <header>\r\n                    <h1>Markdown Previewer</h1>\r\n                </header>\r\n                <div id=\"workspace\"> \r\n                    <Editor text={this.state.editorText} handleChange={this.handleChange} \r\n                        handleMaximize={this.handleMaximize} handleAddPreviewer={this.addPreviewer} \r\n                        handleClear={this.handleClear} identity=\"editor\" \r\n                        maximized={this.state.maximizedComponent} style={editorStyle} />\r\n                    {previewerList}\r\n                </div>\r\n                <div id=\"credits\">Credits:\r\n                    <a href=\"https://marked.js.org/\" id=\"marked\" title=\"marked library\" \r\n                      target=\"_blank\" rel=\"noopener noreferrer\">marked</a>,&nbsp;\r\n                    <a href=\"https://codepen.io/HealerC\" id=\"me\" title=\"codepen@HealerC\" \r\n                      target=\"_blank\" rel=\"noopener noreferrer\">me</a>\r\n                </div>\r\n            </div>\r\n        );\r\n    }\r\n}\r\n\r\nexport default App;","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport App from './app.js';\r\n\r\nReactDOM.render(<App />, document.getElementById(\"root\"));"],"sourceRoot":""}